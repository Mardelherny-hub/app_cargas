<?php

namespace App\Services\Simple;

use App\Models\Company;
use App\Models\User;
use App\Models\Voyage;
use App\Models\Shipment;
use App\Models\WebserviceTransaction;
use App\Models\WebserviceResponse;
use App\Models\WebserviceLog;
use App\Services\Simple\BaseWebserviceService;
use App\Services\Webservice\SoapClientService;
use App\Services\Simple\SimpleXmlGenerator;
use Exception;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Carbon\Carbon;

/**
 * ACTUALIZACIÓN DE POSICIÓN GPS MIC/DTA Argentina AFIP
 * 
 * Servicio especializado para enviar actualizaciones de posición GPS a AFIP
 * durante el viaje de embarcaciones con MIC/DTA activos.
 * 
 * FUNCIONALIDADES:
 * - Enviar coordenadas GPS actuales via ActualizarPosicion AFIP
 * - Validar posiciones GPS antes del envío
 * - Actualizar coordenadas en Shipment (current_latitude/longitude)
 * - Registrar historial de posiciones en WebserviceTransaction
 * - Detectar puntos de control AFIP automáticamente
 * - Calcular distancias y velocidades
 * - Logging completo de actualizaciones GPS
 * 
 * REUTILIZA:
 * - SoapClientService (URLs y configuración AFIP existentes)
 * - BaseWebserviceService (logging y transacciones)
 * - SimpleXmlGenerator (generación XML específico)
 * - Sistema WebserviceTransaction/WebserviceTrack
 * 
 * FLUJO GPS:
 * 1. Validar voyage tiene MIC/DTA enviado exitosamente
 * 2. Obtener coordenadas GPS actuales del shipment
 * 3. Validar coordenadas y calcular cambios
 * 4. Generar XML ActualizarPosicion según especificación AFIP
 * 5. Enviar via SOAP a webservice Argentina
 * 6. Procesar respuesta y actualizar base de datos
 * 7. Detectar puntos de control si aplica
 */
class ArgentinaMicDtaPositionService extends BaseWebserviceService
{
    private SoapClientService $soapClient;
    private SimpleXmlGenerator $xmlGenerator;

    /**
     * Puntos de control AFIP para hidrovía Paraná
     * Coordenadas aproximadas de los principales puntos
     */
    private const CONTROL_POINTS = [
        'ARBUE' => [
            'name' => 'Puerto Buenos Aires',
            'lat' => -34.6118,
            'lng' => -58.3960,
            'radius_km' => 5,
        ],
        'ARROS' => [
            'name' => 'Puerto Rosario',
            'lat' => -32.9442,
            'lng' => -60.6505,
            'radius_km' => 3,
        ],
        'PYASU' => [
            'name' => 'Puerto Asunción',
            'lat' => -25.2637,
            'lng' => -57.5759,
            'radius_km' => 4,
        ],
        'PYTVT' => [
            'name' => 'Terminal Villeta',
            'lat' => -25.5097,
            'lng' => -57.5522,
            'radius_km' => 2,
        ],
    ];

    /**
     * Configuración específica para actualización de posiciones
     */
    protected function getWebserviceConfig(): array
    {
        return [
            'webservice_type' => 'micdta_position',
            'country' => 'AR',
            'environment' => 'testing',
            'soap_action' => 'Ar.Gob.Afip.Dga.wgesregsintia2/ActualizarPosicion',
            'timeout_seconds' => 30,
            'require_certificate' => true,
            'min_update_interval_minutes' => 15, // Mínimo 15 min entre actualizaciones
            'max_daily_updates' => 96, // Máximo 96 updates por día (cada 15 min)
            'position_tolerance_meters' => 50, // Tolerancia de cambio mínimo
        ];
    }

    protected function getWebserviceType(): string
    {
        return 'micdta_position';
    }

    protected function getCountry(): string
    {
        return 'AR';
    }

    protected function getWsdlUrl(): string
    {
        // Usar la misma URL que MIC/DTA principal
        $environment = $this->config['environment'] ?? 'testing';
        $urls = [
            'testing' => 'https://wsaduhomoext.afip.gob.ar/DIAV2/wgesregsintia2/wgesregsintia2.asmx?wsdl',
            'production' => 'https://wsaduext.afip.gob.ar/DIAV2/wgesregsintia2/wgesregsintia2.asmx?wsdl',
        ];
        return $urls[$environment] ?? $urls['testing'];
    }

    public function __construct(Company $company, User $user, array $config = [])
    {
        parent::__construct($company, $user, $config);
        
        // Inicializar servicios reutilizando infraestructura existente
        $this->soapClient = new SoapClientService($company);
        $this->xmlGenerator = new SimpleXmlGenerator($company, $this->config);
    }

    /**
     * Actualizar posición GPS de un voyage específico
     * 
     * @param Voyage $voyage Voyage con MIC/DTA activo
     * @param float $latitude Latitud GPS actual
     * @param float $longitude Longitud GPS actual
     * @param array $options Opciones adicionales
     * @return array Resultado de la actualización
     */
    public function actualizarPosicion(Voyage $voyage, float $latitude, float $longitude, array $options = []): array
    {
        $this->logOperation('info', 'Iniciando actualización de posición GPS', [
            'voyage_id' => $voyage->id,
            'voyage_number' => $voyage->voyage_number,
            'latitude' => $latitude,
            'longitude' => $longitude,
            'company_id' => $this->company->id,
            'user_id' => $this->user->id,
        ]);

        try {
            // Validar que el voyage tiene MIC/DTA enviado exitosamente
            $validacion = $this->validarVoyageParaActualizacion($voyage);
            if (!$validacion['puede_actualizar']) {
                return [
                    'success' => false,
                    'error' => $validacion['error'],
                    'voyage_number' => $voyage->voyage_number,
                ];
            }

            // Validar coordenadas GPS
            if (!$this->validarCoordenadas($latitude, $longitude)) {
                return [
                    'success' => false,
                    'error' => 'Coordenadas GPS inválidas',
                    'latitude' => $latitude,
                    'longitude' => $longitude,
                ];
            }

            // Verificar si es necesario actualizar (evitar spam)
            $necesitaActualizacion = $this->necesitaActualizacion($voyage, $latitude, $longitude);
            if (!$necesitaActualizacion['debe_actualizar']) {
                return [
                    'success' => true,
                    'message' => $necesitaActualizacion['razon'],
                    'skipped' => true,
                    'voyage_number' => $voyage->voyage_number,
                ];
            }

            // Obtener datos del MIC/DTA activo
            $micDtaData = $this->obtenerDatosMicDta($voyage);

            // Crear transacción de seguimiento
            $transaction = $this->crearTransaccionPosicion($voyage, $latitude, $longitude, $options);

            // Generar XML para ActualizarPosicion
            $xmlRequest = $this->generarXmlActualizarPosicion($micDtaData, $latitude, $longitude);

            // Enviar al webservice AFIP
            $soapResult = $this->enviarSoapActualizarPosicion($xmlRequest, $transaction);

            if ($soapResult['success']) {
                // Procesar respuesta exitosa
                $this->procesarRespuestaExitosa($transaction, $voyage, $latitude, $longitude, $soapResult);
                
                return [
                    'success' => true,
                    'message' => 'Posición actualizada exitosamente en AFIP',
                    'voyage_number' => $voyage->voyage_number,
                    'transaction_id' => $transaction->id,
                    'coordinates' => [
                        'lat' => $latitude,
                        'lng' => $longitude,
                    ],
                    'control_point_detected' => $this->detectarPuntoControl($latitude, $longitude),
                    'distance_moved_meters' => $necesitaActualizacion['distance_moved'],
                    'time_since_last_update' => $necesitaActualizacion['time_since_last'],
                ];
            } else {
                // Procesar respuesta de error
                $this->procesarRespuestaError($transaction, $soapResult);
                
                return [
                    'success' => false,
                    'error' => $soapResult['error_message'] ?? 'Error desconocido en actualización AFIP',
                    'voyage_number' => $voyage->voyage_number,
                    'transaction_id' => $transaction->id,
                ];
            }

        } catch (Exception $e) {
            $this->logOperation('error', 'Error en actualización de posición', [
                'voyage_id' => $voyage->id,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
            ]);

            return [
                'success' => false,
                'error' => 'Error interno: ' . $e->getMessage(),
                'voyage_number' => $voyage->voyage_number,
            ];
        }
    }

    /**
     * Actualizar posiciones de múltiples shipments de un voyage
     * 
     * @param Voyage $voyage
     * @return array Resultado de actualizaciones múltiples
     */
    public function actualizarPosicionesVoyage(Voyage $voyage): array
    {
        $this->logOperation('info', 'Iniciando actualización masiva de posiciones', [
            'voyage_id' => $voyage->id,
            'voyage_number' => $voyage->voyage_number,
        ]);

        try {
            // Obtener shipments con coordenadas GPS actualizadas
            $shipments = $voyage->shipments()
                ->whereNotNull('current_latitude')
                ->whereNotNull('current_longitude')
                ->where('position_updated_at', '>=', now()->subHours(2)) // Posiciones recientes
                ->get();

            if ($shipments->isEmpty()) {
                return [
                    'success' => false,
                    'error' => 'No hay shipments con posiciones GPS recientes',
                    'voyage_number' => $voyage->voyage_number,
                ];
            }

            $resultados = [];
            $exitosas = 0;
            $errores = 0;

            foreach ($shipments as $shipment) {
                try {
                    $resultado = $this->actualizarPosicion(
                        $voyage,
                        $shipment->current_latitude,
                        $shipment->current_longitude,
                        ['shipment_id' => $shipment->id]
                    );

                    $resultados[] = array_merge($resultado, [
                        'shipment_id' => $shipment->id,
                    ]);

                    if ($resultado['success'] && !($resultado['skipped'] ?? false)) {
                        $exitosas++;
                    } elseif (!$resultado['success']) {
                        $errores++;
                    }

                    // Pausa entre actualizaciones para evitar saturar AFIP
                    if (count($shipments) > 1) {
                        sleep(2);
                    }

                } catch (Exception $e) {
                    $errores++;
                    $resultados[] = [
                        'success' => false,
                        'error' => $e->getMessage(),
                        'shipment_id' => $shipment->id,
                    ];
                }
            }

            return [
                'success' => true,
                'message' => "Actualización masiva completada: {$exitosas} exitosas, {$errores} errores",
                'voyage_number' => $voyage->voyage_number,
                'shipments_processed' => count($shipments),
                'updates_sent' => $exitosas,
                'errors' => $errores,
                'skipped' => count($shipments) - $exitosas - $errores,
                'resultados' => $resultados,
            ];

        } catch (Exception $e) {
            $this->logOperation('error', 'Error en actualización masiva', [
                'voyage_id' => $voyage->id,
                'error' => $e->getMessage(),
            ]);

            return [
                'success' => false,
                'error' => 'Error en actualización masiva: ' . $e->getMessage(),
                'voyage_number' => $voyage->voyage_number,
            ];
        }
    }

    /**
     * Validar que el voyage puede recibir actualizaciones de posición
     */
    private function validarVoyageParaActualizacion(Voyage $voyage): array
    {
        // Verificar que tiene MIC/DTA enviado exitosamente
        $micDtaTransaction = WebserviceTransaction::where('voyage_id', $voyage->id)
            ->where('company_id', $this->company->id)
            ->where('webservice_type', 'micdta')
            ->where('status', 'sent')
            ->whereNotNull('external_reference')
            ->latest('sent_at')
            ->first();

        if (!$micDtaTransaction) {
            return [
                'puede_actualizar' => false,
                'error' => 'Voyage no tiene MIC/DTA enviado exitosamente',
            ];
        }

        // Verificar que no esté demasiado viejo
        if ($micDtaTransaction->sent_at->diffInDays(now()) > 30) {
            return [
                'puede_actualizar' => false,
                'error' => 'MIC/DTA demasiado antiguo para actualizaciones GPS',
            ];
        }

        return [
            'puede_actualizar' => true,
            'micdta_transaction' => $micDtaTransaction,
        ];
    }

    /**
     * Validar coordenadas GPS
     */
    private function validarCoordenadas(float $lat, float $lng): bool
    {
        // Validación básica de rango
        if ($lat < -90 || $lat > 90 || $lng < -180 || $lng > 180) {
            return false;
        }

        // Validación específica para hidrovía Paraná (aproximada)
        // Latitud: -35 a -20 (desde Buenos Aires hasta Paraguay)
        // Longitud: -62 a -54 (ancho del río y márgenes)
        if ($lat < -35 || $lat > -20 || $lng < -62 || $lng > -54) {
            $this->logOperation('warning', 'Coordenadas fuera del rango esperado para hidrovía Paraná', [
                'lat' => $lat,
                'lng' => $lng,
            ]);
        }

        return true;
    }

    /**
     * Determinar si necesita actualización basado en cambios
     */
    private function necesitaActualizacion(Voyage $voyage, float $newLat, float $newLng): array
    {
        // Buscar última actualización de posición
        $ultimaActualizacion = WebserviceTransaction::where('voyage_id', $voyage->id)
            ->where('company_id', $this->company->id)
            ->where('webservice_type', 'micdta_position')
            ->where('status', 'sent')
            ->latest('sent_at')
            ->first();

        // Si no hay actualizaciones previas, enviar
        if (!$ultimaActualizacion) {
            return [
                'debe_actualizar' => true,
                'razon' => 'Primera actualización de posición',
                'distance_moved' => null,
                'time_since_last' => null,
            ];
        }

        // Verificar intervalo mínimo
        $minutosSinceUltima = $ultimaActualizacion->sent_at->diffInMinutes(now());
        if ($minutosSinceUltima < $this->config['min_update_interval_minutes']) {
            return [
                'debe_actualizar' => false,
                'razon' => "Actualización muy reciente (hace {$minutosSinceUltima} min)",
                'time_since_last' => $minutosSinceUltima,
            ];
        }

        // Calcular distancia desde última posición
        $ultimaPosicion = $ultimaActualizacion->additional_metadata['coordinates'] ?? null;
        if ($ultimaPosicion) {
            $distanciaMetros = $this->calcularDistancia(
                $ultimaPosicion['lat'],
                $ultimaPosicion['lng'],
                $newLat,
                $newLng
            );

            // Si no se movió significativamente, no actualizar
            if ($distanciaMetros < $this->config['position_tolerance_meters']) {
                return [
                    'debe_actualizar' => false,
                    'razon' => "Movimiento mínimo ({$distanciaMetros}m < {$this->config['position_tolerance_meters']}m)",
                    'distance_moved' => $distanciaMetros,
                    'time_since_last' => $minutosSinceUltima,
                ];
            }

            return [
                'debe_actualizar' => true,
                'razon' => "Movimiento significativo: {$distanciaMetros}m en {$minutosSinceUltima} min",
                'distance_moved' => $distanciaMetros,
                'time_since_last' => $minutosSinceUltima,
            ];
        }

        return [
            'debe_actualizar' => true,
            'razon' => 'Sin datos de posición previa',
            'time_since_last' => $minutosSinceUltima,
        ];
    }

    /**
     * Obtener datos del MIC/DTA para referenciar en actualización
     */
    private function obtenerDatosMicDta(Voyage $voyage): array
    {
        $transaction = WebserviceTransaction::where('voyage_id', $voyage->id)
            ->where('company_id', $this->company->id)
            ->where('webservice_type', 'micdta')
            ->where('status', 'sent')
            ->whereNotNull('external_reference')
            ->latest('sent_at')
            ->first();

        return [
            'external_reference' => $transaction->external_reference,
            'transaction_id' => $transaction->transaction_id,
            'sent_at' => $transaction->sent_at,
        ];
    }

    /**
     * Crear transacción para registrar la actualización de posición
     */
    private function crearTransaccionPosicion(Voyage $voyage, float $lat, float $lng, array $options): WebserviceTransaction
    {
        return WebserviceTransaction::create([
            'company_id' => $this->company->id,
            'user_id' => $this->user->id,
            'voyage_id' => $voyage->id,
            'shipment_id' => $options['shipment_id'] ?? null,
            'transaction_id' => 'GPS_' . $voyage->voyage_number . '_' . time(),
            'external_reference' => null, // Se actualiza al recibir respuesta
            'webservice_type' => 'micdta_position',
            'country' => 'AR',
            'status' => 'pending',
            'method_name' => 'ActualizarPosicion',
            'soap_action' => $this->config['soap_action'],
            'webservice_url' => $this->getWsdlUrl(),
            'environment' => $this->config['environment'],
            'additional_metadata' => [
                'coordinates' => [
                    'lat' => $lat,
                    'lng' => $lng,
                ],
                'position_update_type' => 'gps',
                'control_point_detected' => $this->detectarPuntoControl($lat, $lng),
                'update_source' => $options['source'] ?? 'manual',
            ],
        ]);
    }

    /**
     * Generar XML para ActualizarPosicion según especificación AFIP usando SimpleXmlGenerator
     */
    private function generarXmlActualizarPosicion(array $micDtaData, float $lat, float $lng): string
    {
        try {
            // Preparar datos para ActualizarPosicion AFIP
            $positionData = [
                'referencia_micdta' => $micDtaData['external_reference'],
                'coordenadas' => [
                    'latitud' => $lat,
                    'longitud' => $lng,
                    'fecha_hora' => now()->toISOString(),
                ],
                'empresa' => [
                    'cuit' => $this->company->tax_id,
                    'razon_social' => $this->company->legal_name,
                ],
                'usuario' => [
                    'id' => $this->user->id,
                    'nombre' => $this->user->name,
                ],
            ];

            // Usar SimpleXmlGenerator para generar XML según especificación AFIP
            $xmlContent = $this->xmlGenerator->generateXml([
                'method' => 'ActualizarPosicion',
                'data' => $positionData,
                'soap_action' => $this->config['soap_action'],
                'environment' => $this->config['environment'],
            ]);

            $this->logOperation('info', 'XML ActualizarPosicion generado', [
                'xml_size_bytes' => strlen($xmlContent),
                'reference' => $micDtaData['external_reference'],
                'coordinates' => ['lat' => $lat, 'lng' => $lng],
            ]);

            return $xmlContent;

        } catch (Exception $e) {
            $this->logOperation('error', 'Error generando XML ActualizarPosicion', [
                'error' => $e->getMessage(),
                'data' => $positionData ?? null,
            ]);

            // Fallback: XML mínimo funcional
            return $this->generarXmlFallback($micDtaData, $lat, $lng);
        }
    }

    /**
     * Generar XML fallback mínimo en caso de error con SimpleXmlGenerator
     */
    private function generarXmlFallback(array $micDtaData, float $lat, float $lng): string
    {
        $this->logOperation('warning', 'Usando XML fallback para ActualizarPosicion');
        
        return '<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope" xmlns:wges="Ar.Gob.Afip.Dga.wgesregsintia2">
    <soap:Header>
        <wges:AuthSoapHd>
            <wges:ticket>TOKEN_' . $this->company->id . '_' . time() . '</wges:ticket>
            <wges:sign>SIGN_' . hash('sha256', $this->company->tax_id . time()) . '</wges:sign>
            <wges:cuitRepresentado>' . $this->company->tax_id . '</wges:cuitRepresentado>
        </wges:AuthSoapHd>
    </soap:Header>
    <soap:Body>
        <wges:ActualizarPosicion>
            <wges:referenciaMicDta>' . htmlspecialchars($micDtaData['external_reference']) . '</wges:referenciaMicDta>
            <wges:latitud>' . number_format($lat, 8, '.', '') . '</wges:latitud>
            <wges:longitud>' . number_format($lng, 8, '.', '') . '</wges:longitud>
            <wges:fechaHoraPosicion>' . now()->toISOString() . '</wges:fechaHoraPosicion>
            <wges:observaciones>Actualización GPS automática - Sistema ' . config('app.name') . '</wges:observaciones>
        </wges:ActualizarPosicion>
    </soap:Body>
</soap:Envelope>';
    }

    /**
     * Enviar XML via SOAP al webservice AFIP usando SoapClientService real
     */
    private function enviarSoapActualizarPosicion(string $xmlRequest, WebserviceTransaction $transaction): array
    {
        $startTime = microtime(true);
        
        try {
            $this->logOperation('info', 'Iniciando envío ActualizarPosicion SOAP AFIP', [
                'transaction_id' => $transaction->id,
                'xml_size_kb' => round(strlen($xmlRequest) / 1024, 2),
                'webservice_url' => $this->getWsdlUrl(),
            ]);

            // Actualizar transacción antes del envío
            $transaction->update([
                'status' => 'sending',
                'sent_at' => now(),
                'request_xml' => $xmlRequest,
            ]);

            // Usar SoapClientService real (patrón existente del sistema)
            $soapResult = $this->soapClient->sendRequest($transaction, 'ActualizarPosicion', [
                'xmlParam' => $xmlRequest
            ]);

            $endTime = microtime(true);
            $responseTimeMs = round(($endTime - $startTime) * 1000);

            // Actualizar transacción con respuesta
            $transaction->update([
                'status' => 'sent',
                'response_at' => now(),
                'response_time_ms' => $responseTimeMs,
                'response_xml' => $soapResult['response_xml'] ?? null,
            ]);

            // Procesar respuesta AFIP exitosa
            if (isset($soapResult['success']) && $soapResult['success']) {
                $this->logOperation('info', 'Respuesta AFIP ActualizarPosicion exitosa', [
                    'transaction_id' => $transaction->id,
                    'response_time_ms' => $responseTimeMs,
                    'afip_reference' => $soapResult['afip_reference'] ?? null,
                ]);

                return [
                    'success' => true,
                    'response_code' => $soapResult['response_code'] ?? '200',
                    'response_message' => $soapResult['response_message'] ?? 'Posición actualizada exitosamente',
                    'afip_reference' => $soapResult['afip_reference'] ?? 'GPS_' . time(),
                    'response_time_ms' => $responseTimeMs,
                ];
            } else {
                // Respuesta AFIP con error
                $errorMsg = $soapResult['error_message'] ?? 'Error desconocido en respuesta AFIP';
                
                $this->logOperation('error', 'Error en respuesta AFIP ActualizarPosicion', [
                    'transaction_id' => $transaction->id,
                    'error_message' => $errorMsg,
                    'soap_result' => $soapResult,
                ]);

                return [
                    'success' => false,
                    'error_code' => $soapResult['error_code'] ?? '500',
                    'error_message' => $errorMsg,
                    'response_time_ms' => $responseTimeMs,
                ];
            }

        } catch (Exception $e) {
            $endTime = microtime(true);
            $responseTimeMs = round(($endTime - $startTime) * 1000);
            
            $this->logOperation('error', 'Excepción en envío ActualizarPosicion', [
                'transaction_id' => $transaction->id,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'response_time_ms' => $responseTimeMs,
            ]);

            // Actualizar transacción con error
            $transaction->update([
                'status' => 'error',
                'error_count' => ($transaction->error_count ?? 0) + 1,
                'error_message' => $e->getMessage(),
                'response_time_ms' => $responseTimeMs,
            ]);

            return [
                'success' => false,
                'error_code' => '500',
                'error_message' => 'Error de comunicación SOAP: ' . $e->getMessage(),
                'response_time_ms' => $responseTimeMs,
            ];
        }
    }

    /**
     * Procesar respuesta exitosa
     */
    private function procesarRespuestaExitosa(WebserviceTransaction $transaction, Voyage $voyage, float $lat, float $lng, array $soapResult): void
    {
        // Actualizar transacción
        $transaction->update([
            'status' => 'sent',
            'completed_at' => now(),
            'external_reference' => $soapResult['afip_reference'] ?? null,
            'response_code' => $soapResult['response_code'],
            'response_message' => $soapResult['response_message'],
        ]);

        // Actualizar coordenadas en shipments del voyage
        $voyage->shipments()->update([
            'current_latitude' => $lat,
            'current_longitude' => $lng,
            'position_updated_at' => now(),
        ]);

        // Registrar respuesta exitosa
        WebserviceResponse::create([
            'webservice_transaction_id' => $transaction->id,
            'response_code' => $soapResult['response_code'],
            'response_message' => $soapResult['response_message'],
            'response_data' => $soapResult,
            'is_success' => true,
            'processed_at' => now(),
        ]);

        $this->logOperation('info', 'Posición GPS actualizada exitosamente', [
            'transaction_id' => $transaction->id,
            'voyage_id' => $voyage->id,
            'coordinates' => ['lat' => $lat, 'lng' => $lng],
            'afip_reference' => $soapResult['afip_reference'],
        ]);
    }

    /**
     * Procesar respuesta de error
     */
    private function procesarRespuestaError(WebserviceTransaction $transaction, array $soapResult): void
    {
        $transaction->update([
            'status' => 'error',
            'completed_at' => now(),
            'error_count' => ($transaction->error_count ?? 0) + 1,
            'error_message' => $soapResult['error_message'] ?? 'Error desconocido',
        ]);

        WebserviceResponse::create([
            'webservice_transaction_id' => $transaction->id,
            'response_code' => $soapResult['error_code'] ?? '500',
            'response_message' => $soapResult['error_message'] ?? 'Error desconocido',
            'response_data' => $soapResult,
            'is_success' => false,
            'processed_at' => now(),
        ]);

        $this->logOperation('error', 'Error en actualización GPS', [
            'transaction_id' => $transaction->id,
            'error_message' => $soapResult['error_message'],
        ]);
    }

    /**
     * Detectar si está cerca de un punto de control AFIP
     */
    private function detectarPuntoControl(float $lat, float $lng): ?array
    {
        foreach (self::CONTROL_POINTS as $codigo => $punto) {
            $distanciaKm = $this->calcularDistancia($lat, $lng, $punto['lat'], $punto['lng']) / 1000;
            
            if ($distanciaKm <= $punto['radius_km']) {
                return [
                    'codigo' => $codigo,
                    'nombre' => $punto['name'],
                    'distancia_km' => round($distanciaKm, 2),
                ];
            }
        }

        return null;
    }

    /**
     * Calcular distancia entre dos puntos GPS (fórmula haversine)
     */
    private function calcularDistancia(float $lat1, float $lng1, float $lat2, float $lng2): float
    {
        $earthRadius = 6371000; // Radio de la Tierra en metros

        $dLat = deg2rad($lat2 - $lat1);
        $dLng = deg2rad($lng2 - $lng1);

        $a = sin($dLat / 2) * sin($dLat / 2) +
             cos(deg2rad($lat1)) * cos(deg2rad($lat2)) *
             sin($dLng / 2) * sin($dLng / 2);

        $c = 2 * atan2(sqrt($a), sqrt(1 - $a));

        return $earthRadius * $c;
    }

    /**
     * Obtener historial de posiciones de un voyage
     */
    public function obtenerHistorialPosiciones(Voyage $voyage, int $dias = 7): array
    {
        $transacciones = WebserviceTransaction::where('voyage_id', $voyage->id)
            ->where('company_id', $this->company->id)
            ->where('webservice_type', 'micdta_position')
            ->where('status', 'sent')
            ->where('created_at', '>=', now()->subDays($dias))
            ->orderBy('sent_at', 'desc')
            ->get();

        $historial = [];
        foreach ($transacciones as $transaction) {
            $coordinates = $transaction->additional_metadata['coordinates'] ?? null;
            if ($coordinates) {
                $historial[] = [
                    'timestamp' => $transaction->sent_at->toISOString(),
                    'lat' => $coordinates['lat'],
                    'lng' => $coordinates['lng'],
                    'control_point' => $transaction->additional_metadata['control_point_detected'],
                    'transaction_id' => $transaction->id,
                ];
            }
        }

        return $historial;
    }

    /**
     * Validaciones específicas (requerido por BaseWebserviceService)
     */
    protected function validateSpecificData($data): array
    {
        return ['errors' => [], 'warnings' => []];
    }
}